# -*- coding: utf-8 -*-
"""BFB,ipynb-vishruth.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Wt0RR-LGkK0tQLbhVt1JGxADtLZQdm-r
"""

import uuid
import struct
import random
from bplustree import BPlusTree


tree = BPlusTree("./merchants.db", order=50)

str(uuid.uuid4())

unique_numbers = set()

# Generate random 6-digit numbers until we have 30,000 unique numbers
while len(unique_numbers) < 30000:
    unique_numbers.add(random.randint(100000, 999999))

# Convert the set to a list
pincodes = list(unique_numbers)
random.shuffle(pincodes)

pincodes[5684]


# Dictionary to store UUID strings as keys
merchant_id_hash = {}

# Generate unique merchant IDs until we have 10,000,000 unique IDs
while len(merchant_id_hash) < 10000000:
    # Generate a UUID
    uuid_string = str(uuid.uuid4())

    # Store the UUID string in the dictionary with an arbitrary value
    merchant_id_hash[uuid_string] = None

len(merchant_id_hash)

for i, uuid_string in enumerate(merchant_id_hash.keys()):
    print(f"{i+1}: UUID: {uuid_string}")
    if i == 4:
        break

len(pincodes)

merchant_ids = list(merchant_id_hash.keys())


def add_mapping(pincode):
    # Randomly determine the number of merchants serving this pincode
    # Adjusted upper limit to 600 merchants per pincode
    num_merchants = random.randint(0, 600)
    # Generate a list of merchants for the current pincode
    merchants = random.sample(merchant_ids, num_merchants)
    # Pack the merchant IDs into byte data
    byte_data = b''.join(merchant_id.encode() for merchant_id in merchants)
    # Insert the mapping into the B+ tree
    tree.insert(pincode, byte_data, replace=True)


# Apply the 'add_mapping' function to each pincode
list(map(add_mapping, pincodes))


def add(merchant_id):
    # Randomly determine the number of pincodes for each merchant (between 0 and 300)
    num_pincodes = random.randint(0, 300)

    # Generate a list of pincodes for the current merchant
    merchant_pincodes = random.sample(pincodes, num_pincodes)

    # Pack the pincodes into byte data
    byte_data = struct.pack('!{}I'.format(
        len(merchant_pincodes)), *merchant_pincodes)

    # Insert the merchant-pincodes association into the B+ tree
    tree.insert(merchant_id, byte_data, replace=True)


# Apply the 'add' function to each merchant
list(map(add, merchant_ids))

j = 310


def add(i):
    global j
    merchants = [k for k in range(j-300, j)]
    j += 310
    byte_data = struct.pack('!{}I'.format(len(merchants)), *merchants)
    tree.insert(i, byte_data, replace=True)


L = list(range(0, 30000))
random.shuffle(L)
list(map(add, L))
# "Noice"

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# #len(tree)


def get_merchants_for_pincode(pincode):
    # Retrieve byte data from the B+ tree for the given pincode
    byte_data = tree.get(pincode)
    if byte_data:
        # Calculate the number of merchants based on the length of the byte data
        print(len(byte_data))
        num_merchants = len(byte_data) // 36
        # Unpack byte data to get the list of merchants
        merchants = struct.unpack(f'!{num_merchants * 36}s', byte_data)
        # Decode merchant IDs from bytes to strings
        merchant_ids = [merchant.decode() for merchant in merchants]
        return merchant_ids
    else:
        return []


t = get_merchants_for_pincode(524286)
split_strings = [s[i:i+36] for s in t for i in range(0, len(s), 36)]
final_merchants = "\n".join(split_strings)

# Print the UUIDs
# print(len(split_strings))

final_merchants

tree.close()
